// Este código assume que os dados de entrada do nó "Code" vêm do nó anterior (Webhook ou similar).
// O n8n geralmente coloca os dados de entrada em 'items[0].json' para um único item.

const incomingData = items[0].json;

// O payload real do webhook está dentro da propriedade 'body' do objeto incomingData.
const webhookPayload = incomingData.body;

// Inicializa um array para armazenar os eventos formatados.
const formattedEvents = [];

// Garante que 'webhookPayload' seja tratado como um array para processamento consistente,
// mesmo que o webhook envie um único objeto.
const eventsToProcess = Array.isArray(webhookPayload) ? webhookPayload : [webhookPayload];

for (const event of eventsToProcess) {
  // Agora 'event' refere-se ao objeto de evento real (ex: { event: "messages.upsert", data: {...} })
  if (event.event === 'messages.upsert' && event.data?.key && event.data?.message) {
    const formattedEvent = {
      event: event.event,
      data: {
        key: {
          remoteJid: event.data.key.remoteJid,
          fromMe: event.data.key.fromMe,
          id: event.data.key.id
        },
        message: {
          // Prioriza 'conversation', mas usa 'extendedTextMessage.text' se 'conversation' estiver vazio.
          conversation: event.data.message.conversation || event.data.message.extendedTextMessage?.text || ''
        }
      }
    };
    formattedEvents.push(formattedEvent);
  }
  // Se houver outros tipos de eventos que você queira processar, adicione 'else if' aqui.
}

// Retorna um array de itens, onde cada item tem uma propriedade 'json' que é um objeto.
// Se formattedEvents for vazio, retornará um array vazio.
return formattedEvents.map(event => ({ json: event }));